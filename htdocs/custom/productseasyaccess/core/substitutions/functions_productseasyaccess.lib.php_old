<?php
/* Copyright (C) 2012   Stephen Larroque <lrq3000@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * at your option any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *      \file             htdocs/productseasyaccess/core/substitutions/functions_productseasyaccess.lib.php
 *      \ingroup    productseasyaccess
 *      \brief          Substition function for the ODT templating (render accessible all the products standard and custom fields)
 *      \author      Stephen Larroque
 */

/** Useless function necessary for old Dolibarr versions not to throw an error (because as soon as it sees this file, it will necessarily call to this function...)
 *
 */
function productseasyaccess_completesubstitutionarray(&$substitutionarray,$langs,$object) {
    return;
}

/** 		Function called to complete the substitution array (before generating on ODT, or a personalized email)
 * 		functions xxx_completesubstitutionarray are called by make_substitutions() if file
 * 		is inside directory htdocs/core/mymodule/substitutions/
 *
 *		@param	array		$substitutionarray	Array with substitution key=>val
 *		@param	Translate	$langs			Output langs
 *		@param	Object		$object			Object to use to get values
 *	        @param	Object		$parameters	Contains the current line object being processed (this will change for every call to this function) AND odfHandler (necessary to embed images)
 * 		@return	void					The entry parameter $substitutionarray is modified
 */

function productseasyaccess_completesubstitutionarray_lines(&$substitutionarray,$langs,$object,$parameters) {
    global $conf, $db;

    $parameters = (array)$parameters; // convert the $parameters because sometimes an object is returned instead of an array

    // Init parameters
    $line = $parameters['line'];
    $odfHandler = $parameters['odfHandler'];

    // Init caching
    static  $productslinescache; // cache for the lines' customfields (their data won't change between two successive calls of this function)
    static $sqlwrapper; // cache the SQL Wrapper object
    static $collist; // cache the list of columns, so that for next lines where there's no link to a predefined product, we can just replace the product's tags by empty strings

    if (!isset($productslinescache)) $productslinescache = new stdClass(); // initialize the cache object (avoid php >= 5.3 warnings)

    if (empty($object) or empty($line)) return; // check that this function is called with an $object and $line for substitution in ODTs (else it may be called in the email config page and create a bug)

    // Process only if the module is enabled (because this substitution function may be called even if the module is disabled)
    if ($conf->global->MAIN_MODULE_PRODUCTSEASYACCESS) {

        // Get the lines segment
        // NOTE: setSegment returns a segment if it already exists (it won't create it)
        // NOTE2: the segment will NOT contain only one segment, but incrementally all segments (try to print $listlines->getXmlParsed() to convince yourself, you will see that at each iteration of the loop, it will contain all previously generated data, all but the current iteration because it's not already generated using $listlines->merge() !)
        // NOTE3: $listlines->merge() will append the current segment to the list, so everytime you call merge() it will append the same segment (with your latest modifications like setVars() or setImage()). $odfHandler->mergeSegment('lines') will output and seal all that was generated by the segment.
        // NOTE4: so in fact, at every iteration, we do NOT get a single segment, but rather we append a new segment over the previously generated segment(s), but it still counts as only a single segment all along!
        $listlines = $odfHandler->setSegment('lines');

        // == FETCHING FIELDS
        // If there's no cache yet, we fetch ALL the products' fields (we get every fields' values for every products linked to this $object)
        if (empty($productslinescache->{$object->table_element})) {
            include_once(dirname(__FILE__).'/../../lib/productseasyaccess.lib.php');
            fill_object_with_products_fields($object, null, $langs); // fetch the fields for all products (standard and custom fields)
            $productslinescache->{$object->table_element} = $object->productslines; // save the result into a cache (different for each module, will avoid conflicts if there are multiple generating functions called at once)
        // Else if the cache exists, we use it directly (this dramatically lowers the processing time because we query the database only once for ALL products and fields at once, so next time this function is called for the next line, we already have everything ready and it will be blazingly fast)
        } else {
            $object->productslines = $productslinescache->{$object->table_element}; // load the cache
        }

        // == SUBSTITUTION
        // If this product line is linked to a predefined product, then we can substitute with the product's fields (standard and custom fields)
        if (!empty($line->fk_product) and !empty($object->productslines->{$line->fk_product})) {
            // -- Begin to populate the substitution array with product's data
            foreach ($object->productslines->{$line->fk_product} as $key=>$value) { // One field at a time, relative to the current line being processed
                // If this is not a photo, we do the standard procedure
                if (!(strpos($key, 'photo') === 0)) {
                    // Add this customfield's data to the substitution array (will automatically be replaced inside the ODT, eg: {line_weight} becomes '0.2314')
                    $substitutionarray['line_'.$key] = $value; // adding this value to an odt variable (format: {line_myfield} for standard fields or {line_cf_myfield} if it is a custom field)
                // Else if it is a photo, it oughts to be treated differently
                } else {
                    // TRICK: we DON'T put the variable into the substitution array, but rather we put it into another key, because we want the key of the photo to NOT be substituted but replaced by an image.
                    $substitutionarray['line_'.$key.'_path'] = $value; // thus we store the variable into another key (eg: {line_photo1_path}), which will be used later to detect if this photo is defined or not (so that we can delete photo tags which are empties)
                    // Exception handling (see below for the explanation)
                    try {
                        // We set an image. It will be included inside the ODT via PclZip (PclZipProxy).
                        $listlines->setImage('line_'.$key, $value); // Note: the image will be linked to the variable {line_photox} which means that you need to NOT substitute this variable, else the substitution will take over the image and the image won't be included in the document!
                    } catch(Exception $e) {
                        // TODO: setImage will fail if the tag is not found in the document. We should enhance odf.php to be resilient against this kind of failure (just like it already is with substitution), but meanwhile this workaround works.
                    }
                }

            }

        // Else if this product is NOT a predefined product (a free product line), then there's no product's fields to fetch, BUT we still must erase the tags to avoid leaving non transformed tags in the rendered ODT document
        } else {
            // If there's no cache yet, we load all the columns (fields) from the database
            if (empty($collist)) {
                // Init the final list of products' fields
                $collist = array();
                // Init SQL wrapper if not defined
                if (!isset($sqlwrappe)) {
                    include_once(dirname(__FILE__).'/../../class/sqlwrapper.class.php');
                    $sqlwrapper = new SQLWrapper($db);
                }
                // Fetching products' standard fields list
                $collist1 = $sqlwrapper->fetchAny('column_name', 'information_schema.columns',"table_schema = '".$db->database_name."'AND table_name = '".MAIN_DB_PREFIX.'product'."'");
                foreach ($collist1 as $col) { // Store the columns in the final list
                    $collist[] = $col->column_name;
                }
                // Fetching products' custom fields list
                if ($conf->global->MAIN_MODULE_CUSTOMFIELDS) {
                    // Loading the CustomFields config (needed to load the custom fields prefix)
                    include(DOL_DOCUMENT_ROOT.'/customfields/conf/conf_customfields.lib.php');
                    $collist2 = $sqlwrapper->fetchAny('column_name', 'information_schema.columns',"table_schema = '".$db->database_name."'AND table_name = '".MAIN_DB_PREFIX.'product_customfields'."'");
                    foreach ($collist2 as $col) { // Store the columns in the final list
                        $collist[] = $fieldsprefix.$col->column_name;
                    }
                }
            }

            // Substitute all products' fields by an empty string (since they are not linked to a predefined product, else if we don't do that it will leave the ODT tags as is)
            foreach ($collist as $col) {
                $substitutionarray['line_'.$col] = '';
            }
        }

        // Finally, clean up any photo tag that was not converted into an image (we do this because photos aren't stored inside the database, so we must specify these 'artificial' fields manually)
        for($i=1;$i<=10;$i++) {
            // We detect if the {line_photo$i_path} variable exists, if true then the photo exists, else it's empty and we want to delete these empty tags
            if (empty($substitutionarray['line_photo'.$i.'_path'])) {
                $substitutionarray['line_photo'.$i] = ''; // replace the tag by nothing
                $substitutionarray['line_photo'.$i.'_thumbnail'] = '';
            }
        }

    }
}
